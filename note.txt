GLOBAL ERROR HANDLER

​Implementing a global error handler in your Express.js application centralizes error management, making your codebase cleaner and more maintainable. Express provides a built-in error-handling mechanism, but setting up a custom global error handler allows for more tailored responses and logging.

Steps to Implement a Global Error Handler in Express.js:

Create an Error-Handling Middleware Function:
Define a middleware function that accepts four parameters: err, req, res, and next. This function will handle errors passed to it.

// errorHandler.js
function errorHandler(err, req, res, next) {
  console.error(err.stack); // Log the error stack for debugging
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';
  res.status(statusCode).json({
    success: false,
    status: statusCode,
    message: message,
    stack: process.env.NODE_ENV === 'development' ? err.stack : {}
  });
}
module.exports = errorHandler;


2.Integrate the Error Handler into Your Express App:
In your main application file (e.g., app.js), import and use the error handler after all route handlers and other middleware.

// app.js
const express = require('express');
const errorHandler = require('./errorHandler');
const app = express();

// Your route handlers and other middleware go here

// Use the error handler middleware after all routes and middleware
app.use(errorHandler);

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});



*********************************************************

LETS  CREATE A GLOBAL ERROR HANDLING MIDDLEWARE.

Explaining the code at error.middleware.js file.

This code defines an Express error-handling middleware function called `errorMiddleware` that:

1. Takes an error object and standard Express request/response/next parameters
2. Creates a copy of the error and sets a default message if none exists
3. Handles specific types of errors:
   - Mongoose CastError (invalid ID format): Returns 404 "Resource Not Found"
   - MongoDB duplicate key errors (code 11000): Returns 400 "Duplicate field value entered"
   - Mongoose validation errors: Returns 400 with all validation messages concatenated
4. For other errors, defaults to status code 500 and "Server Error" message
5. Sends a JSON response with success:false and the error message
6. Has a try-catch block that passes any unexpected errors to the next middleware
7. Is exported for use in other files

The middleware provides structured error handling for common database-related errors while maintaining a consistent error response format.



*****************************************************
EXPLAINING SOME EXPRESS BUILTING MIDDLEWARE WE INCLUDED IN APP.JS.

These are built-in and third-party middleware functions in Express.js that handle different types of incoming request data:

1. express.json()
Purpose: Parses incoming requests with JSON payloads (data sent in JSON format).

How it works:
Reads the request body if the Content-Type header is application/json.
Converts the JSON data into a JavaScript object.
Makes the parsed data available in req.body.

2. express.urlencoded({ extended: false })
Purpose: Parses incoming form data (typically from HTML forms).

Parameters:
extended: false uses the querystring library (simpler key-value pairs).

extended: true allows nested objects (uses qs library).

How it works:
Reads data when the Content-Type is application/x-www-form-urlencoded.
Parses the data into req.body.

3. cookieParser()
Purpose: Parses cookies attached to incoming requests (a third-party middleware).

How it works:
Reads the Cookie header and converts it into a JavaScript object.
Stores parsed cookies in req.cookies.

Why They’re Used Together:
Combined, these middleware cover common data formats:

JSON (APIs), URL-encoded forms (web submissions), and cookies (sessions/tracking).
They ensure req.body and req.cookies are populated for downstream routes.

Key Notes:
Order Matters: These should be mounted early (before routes that need them).

Security: cookieParser() is essential for sessions but requires careful configuration (e.g., signed: true for signed cookies).

Example Setup:
const express = require('express');
const cookieParser = require('cookie-parser');

const app = express();

app.use(express.json()); // Parse JSON bodies
app.use(express.urlencoded({ extended: false })); // Parse form data
app.use(cookieParser()); // Parse cookies

// Routes can now access req.body, req.cookies, etc.